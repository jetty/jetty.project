//
// ========================================================================
// Copyright (c) 1995-2022 Mort Bay Consulting Pty Ltd and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// https://www.eclipse.org/legal/epl-2.0, or the Apache License, Version 2.0
// which is available at https://www.apache.org/licenses/LICENSE-2.0.
//
// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
// ========================================================================
//

package org.eclipse.jetty.server.handler;

import java.util.List;

import org.eclipse.jetty.http.HttpURI;
import org.eclipse.jetty.server.Context;
import org.eclipse.jetty.server.Handler;
import org.eclipse.jetty.server.Request;
import org.eclipse.jetty.util.URIUtil;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * <p>Inspired by nginx's {@code try_files} functionality.</p>
 *
 * <p> This handler can be configured with a list of URI paths.
 * The special token {@code $path} represents the current request
 * {@code pathInContext} (the portion after the context path).</p>
 *
 * <p>Typical example of how this handler can be configured is the
 * following:</p>
 * <pre>{@code
 * [Handlers are organized in the following structure]
 * ContextHandler
 * `- TryPathsHandler
 *    |- ResourceHandler
 *    `- Handler (forward)
 *
 * ContextHandler contextHandler = new ContextHandler("/foo");
 * contextHandler.setBaseResource(rootPath);
 *
 * TryPathsHandler tryPathsHandler = new TryPathsHandler();
 * contextHandler.setHandler(tryPathsHandler);
 *
 * // Link a ResourceHandler to serve static files.
 * tryPathsHandler.setHandler(new ResourceHandler());
 *
 * // Link your forward Handler to handle dynamic requests.
 * tryPathsHandler.setForwardHandler(new MyHandler());
 *
 * tryPathsHandler.setPaths(List.of("/maintenance.html", "$path", "/index.jsp?p=$path"));
 * }</pre>
 *
 * <p>For a request such as {@code /context/path/to/resource.ext}, this
 * handler will try to serve the {@code /maintenance.html} file if it finds
 * it; failing that, it will try to serve the {@code /path/to/resource.ext}
 * file if it finds it; failing that it will forward the request to
 * {@code /index.php?p=/path/to/resource.ext} to the next handler.</p>
 * <p>The last path specified in the list is therefore the "forward" path to
 * which the request is forwarded to in case no previous file can be found.</p>
 * <p>The file paths are resolved against {@link Context#getBaseResource()}
 * to make sure that only files visible to the application are served.</p>
 *
 * <p>This handler could be used to serve static files/pages that
 * are generated by the {@link #getForwardHandler()} forward handler}.
 * A first request generates the file/page that is stored under the
 * {@link ContextHandler#getBaseResource()}, so that a second request
 * will serve the static file, rather than generating it again.</p>
 */
public class TryPathsHandler extends Handler.Wrapper
{
    private static final Logger LOG = LoggerFactory.getLogger(TryPathsHandler.class);

    private Handler forwardHandler;
    private List<String> paths;

    public TryPathsHandler()
    {
        this(null, null);
    }

    public TryPathsHandler(Handler handler, Handler forwardHandler)
    {
        super(handler);
        this.forwardHandler = forwardHandler;
    }

    public Handler getForwardHandler()
    {
        return forwardHandler;
    }

    public void setForwardHandler(Handler forwardHandler)
    {
        this.forwardHandler = forwardHandler;
    }

    public List<String> getPaths()
    {
        return paths;
    }

    public void setPaths(List<String> paths)
    {
        this.paths = List.copyOf(paths);
    }

    @Override
    public Request.Processor handle(Request request) throws Exception
    {
        List<String> paths = getPaths();
        if (paths == null || paths.isEmpty())
            paths = List.of("$path");

        if (LOG.isDebugEnabled())
            LOG.debug("trying paths {} for {}", paths, request);

        for (int i = 0; i < paths.size() - 1; ++i)
        {
            String path = paths.get(i);
            String interpolated = interpolate(request, path);
            Request.WrapperProcessor wrapper = new Request.WrapperProcessor(new TryPathsRequest(request, interpolated));
            Request.Processor processor = super.handle(wrapper);

            if (LOG.isDebugEnabled())
                LOG.debug("interpolated {} to {} for {}, processor {}", path, interpolated, request, processor);

            if (processor != null)
                return wrapper.wrapProcessor(processor);
        }

        Handler forwardHandler = getForwardHandler();
        if (forwardHandler == null)
            return null;

        String forward = paths.get(paths.size() - 1);
        String interpolated = interpolate(request, forward);
        Request.WrapperProcessor wrapper = new Request.WrapperProcessor(new TryPathsRequest(request, interpolated));
        Request.Processor processor = forwardHandler.handle(wrapper);

        if (LOG.isDebugEnabled())
            LOG.debug("interpolated {} to {} for {}, forwarding processor {}", forward, interpolated, request, processor);

        return wrapper.wrapProcessor(processor);
    }

    private String interpolate(Request request, String value)
    {
        String path = Request.getPathInContext(request);
        String interpolated = value.replace("$path", path);
        if (!interpolated.startsWith("/"))
            interpolated = "/" + interpolated;
        return interpolated;
    }

    private static class TryPathsRequest extends Request.Wrapper
    {
        private final HttpURI _uri;

        public TryPathsRequest(Request wrapped, String pathInContext)
        {
            super(wrapped);
            _uri = Request.newHttpURIFrom(wrapped, URIUtil.canonicalPath(pathInContext));
        }

        @Override
        public HttpURI getHttpURI()
        {
            return _uri;
        }
    }
}
