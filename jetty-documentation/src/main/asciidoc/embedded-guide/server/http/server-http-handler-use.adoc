//
// ========================================================================
// Copyright (c) 1995-2020 Mort Bay Consulting Pty Ltd and others.
//
// This program and the accompanying materials are made available under
// the terms of the Eclipse Public License 2.0 which is available at
// https://www.eclipse.org/legal/epl-2.0
//
// This Source Code may also be made available under the following
// Secondary Licenses when the conditions for such availability set
// forth in the Eclipse Public License, v. 2.0 are satisfied:
// the Apache License v2.0 which is available at
// https://www.apache.org/licenses/LICENSE-2.0
//
// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
// ========================================================================
//

[[eg-server-http-handler-use]]
==== Using Provided Handlers

Web applications are the unit of deployment in an HTTP server or Servlet
container such as Jetty.

Two different web applications are typically deployed on different
__context path__s, where a _context path_ is the initial segment of the URI
path.
For example, web application `webappA` that implements a web user interface
for an e-commerce site may be deployed to context path `/shop`, while web
application `webappB` that implements a REST API for the e-commerce business
may be deployed to `/api`.

A client making a request to URI `/shop/cart` is directed by Jetty to
`webappA`, while a request to URI `/api/products` is directed to `webappB`.

An alternative way to deploy the two web applications of the example above
is to use _virtual hosts_.
A _virtual host_ is a subdomain of the primary domain that shares the same
IP address with the primary domain.
If the e-commerce business primary domain is `domain.com`, then a virtual
host for `webappA` could be `shop.domain.com`, while a virtual host for
`webappB` could be `api.domain.com`.

Web application `webappA` can now be deployed to virtual host
`shop.domain.com` and context path `/`, while web application `webappB`
can be deployed to virtual host `api.domain.com` and context path `/`.
Both applications have the same context path `/`, but they can be
distinguished by the subdomain.

A client making a request to `+https://shop.domain.com/cart+` is
directed by Jetty to `webappA`, while a request to
`+https://api.domain.com/products+` is directed to `webappB`.

Therefore, in general, a web application is deployed to a _context_
which can be seen as the pair `(virtual_host, context_path)`.
In the first case the contexts were `(domain.com, /shop)` and
`(domain.com, /api)`, while in the second case the contexts were
`(shop.domain.com, /)` and `(api.domain.com, /)`.
Server applications using the Jetty Server Libraries create and
configure a _context_ for each web application.

[[eg-server-http-handler-use-context]]
===== ContextHandler

`ContextHandler` is a `Handler` that represents a _context_ for a web
application. It is a `HandlerWrapper` that performs some action before
and after delegating to the nested `Handler`.
// TODO: expand on what the ContextHandler does, e.g. ServletContext.

The simplest use of `ContextHandler` is the following:

[source,java,indent=0]
----
include::../../{doc_code}/embedded/server/http/HTTPServerDocs.java[tags=contextHandler]
----

The `Handler` tree structure looks like the following:

[source,screen]
----
Server
└── ContextHandler /shop
    └── ShopHandler
----

[[eg-server-http-handler-use-context-collection]]
===== ContextHandlerCollection

Server applications may need to deploy to Jetty more than one web application.

Recall from the xref:eg-server-http-handler[introduction] that Jetty offers
`HandlerCollection` and `HandlerList` that may contain a sequence of children
``Handler``s.
However, both of these have no knowledge of the concept of _context_ and just
iterate through the sequence of ``Handler``s.

A better choice for multiple web application is `ContextHandlerCollection`,
that matches a _context_ from either its _context path_ or _virtual host_,
without iterating through the ``Handler``s.

If `ContextHandlerCollection` does not find a match, it just returns.
What happens next depends on the `Handler` tree structure: other ``Handler``s
may be invoked after `ContextHandlerCollection`, for example `DefaultHandler`
(see xref:eg-server-http-handler-use-util-default-handler[this section]).
Eventually, if `Request.setHandled(true)` is not called, Jetty returns a HTTP
`404` response to the client.

[source,java,indent=0]
----
include::../../{doc_code}/embedded/server/http/HTTPServerDocs.java[tags=contextHandlerCollection]
----

The `Handler` tree structure looks like the following:

[source,screen]
----
Server
└── ContextHandlerCollection
    ├── ContextHandler /shop
    │   └── ShopHandler
    └── ContextHandler /api
        └── RESTHandler
----

[[eg-server-http-handler-use-servlet-context]]
===== ServletContextHandler

``Handler``s are easy to write, but often web applications have already been
written using the Servlet APIs, using ``Servlet``s and ``Filter``s.

`ServletContextHandler` is a `ContextHandler` that provides support for the
Servlet APIs and implements the behaviors required by the Servlet specification.

The Maven artifact coordinates are:

[source,xml,subs=normal]
----
<dependency>
  <groupId>org.eclipse.jetty</groupId>
  <artifactId>jetty-servlet</artifactId>
  <version>{version}</version>
</dependency>
----

[source,java,indent=0]
----
include::../../{doc_code}/embedded/server/http/HTTPServerDocs.java[tags=servletContextHandler]
----

The `Handler` and Servlet components tree structure looks like the following:

[source,screen,subs=normal]
----
Server
└── ServletContextHandler /shop
    ├── _ShopCartServlet /cart/*_
    └── _CrossOriginFilter /*_
----

Note how the Servlet components (they are not ``Handler``s) are represented in
_italic_.

Note also how adding a `Servlet` or a `Filter` returns a _holder_ object that
can be used to specify additional configuration for that particular `Servlet`
or `Filter`.

When a request arrives to `ServletContextHandler` the request URI will be
matched against the ``Filter``s and ``Servlet`` mappings and only those that
match will process the request, as dictated by the Servlet specification.

IMPORTANT: `ServletContextHandler` is a terminal `Handler`, that is it always
calls `Request.setHandled(true)` when invoked.
Server applications must be careful when creating the `Handler`
tree to put ``ServletContextHandler``s as last ``Handler``s in a `HandlerList`
or as children of `ContextHandlerCollection`.

[[eg-server-http-handler-use-webapp-context]]
===== WebAppContext

`WebAppContext` is a `ServletContextHandler` that auto configures itself by
reading a `web.xml` Servlet configuration file.

Server applications can specify a `+*.war+` file or a directory with the
structure of a `+*.war+` file to `WebAppContext` to deploy a standard Servlet
web application packaged as a `war` (as defined by the Servlet specification).

Where server applications using `ServletContextHandler` must manually invoke
methods to add ``Servlet``s and ``Filter``s, `WebAppContext` reads
`WEB-INF/web.xml` to add ``Servlet``s and ``Filter``s.

[source,java,indent=0]
----
include::../../{doc_code}/embedded/server/http/HTTPServerDocs.java[tags=webAppContextHandler]
----

[[eg-server-http-handler-use-resource-handler]]
===== ResourceHandler -- Static Content

Static content such as images or files (HTML, JavaScript, CSS) can be sent
by Jetty very efficiently because Jetty can write the content asynchronously,
using direct ``ByteBuffer``s to minimize data copy, and using a memory cache
for faster access to the data to send.

Being able to write content asynchronously means that if the network gets
congested (for example, the client reads the content very slowly) and the
server stalls the send of the requested data, then Jetty will wait to resume
the send _without_ blocking a thread to finish the send.

`ResourceHandler` supports the following features:

* Welcome files, for example serving `/index.html` for request URI `/`
* Precompressed resources, serving a precompressed `/document.txt.gz` for
request URI `/document.txt`
* link:https://tools.ietf.org/html/rfc7233[Range requests], for requests
containing the `Range` header, which allows clients to pause and resume
downloads of large files
* Directory listing, serving a HTML page with the file list of the requested
directory
* Conditional headers, for requests containing the `If-Match`, `If-None-Match`,
`If-Modified-Since`, `If-Unmodified-Since` headers.

The number of features supported and the efficiency in sending static content
are on the same level as those of common front-end servers used to serve
static content such as Nginx or Apache.
Therefore, the traditional architecture where Nginx/Apache was the front-end
server used only to send static content and Jetty was the back-end server used
only to send dynamic content is somehow obsolete as Jetty can perform
efficiently both tasks.
This leads to simpler systems (less components to configure and manage) and
more performance (no need to proxy dynamic requests from front-end servers
to back-end servers).

NOTE: It is common to use Nginx/Apache as load balancers, or as rewrite/redirect
servers. We typically recommend link:https://haproxy.org[HAProxy] as load
balancer, and Jetty has
xref:eg-server-http-handler-use-util-rewrite-handler[rewrite/redirect features]
as well.

This is how you configure a `ResourceHandler` to create a simple file server:

[source,java,indent=0]
----
include::../../{doc_code}/embedded/server/http/HTTPServerDocs.java[tags=resourceHandler]
----

If you need to serve static resources from multiple directories:

[source,java,indent=0]
----
include::../../{doc_code}/embedded/server/http/HTTPServerDocs.java[tags=multipleResourcesHandler]
----

If the resource is not found, `ResourceHandler` will not call
`Request.setHandled(true)` so what happens next depends on the `Handler`
tree structure. See also
xref:eg-server-http-handler-use-util-default-handler[how to use] `DefaultHandler`.

[[eg-server-http-handler-use-default-servlet]]
===== DefaultServlet -- Static Content for Servlets

If you have a
xref:eg-server-http-handler-use-servlet-context[Servlet web application],
you may want to use a `DefaultServlet` instead of `ResourceHandler`.
The features are similar, but `DefaultServlet` is more commonly used to
serve static files for Servlet web applications.

[source,java,indent=0]
----
include::../../{doc_code}/embedded/server/http/HTTPServerDocs.java[tags=defaultServlet]
----

[[eg-server-http-handler-use-util-gzip-handler]]
===== GzipHandler

`GzipHandler` provides supports for automatic decompression of compressed
request content and automatic compression of response content.

`GzipHandler` is a `HandlerWrapper` that inspects the request and, if the
request matches the `GzipHandler` configuration, just installs the required
components to eventually perform decompression of the request content or
compression of the response content.
The decompression/compression is not performed until the web application
reads request content or writes response content.

`GzipHandler` can be configured at the server level in this way:

[source,java,indent=0]
----
include::../../{doc_code}/embedded/server/http/HTTPServerDocs.java[tags=serverGzipHandler]
----

The `Handler` tree structure looks like the following:

[source,screen]
----
Server
└── GzipHandler
    └── ContextHandlerCollection
        ├── ContextHandler 1
        :── ...
        └── ContextHandler N
----

However, in less common cases, you can configure `GzipHandler` on a
per-context basis, for example because you want to configure `GzipHandler`
with different parameters for each context, or because you want only some
contexts to have compression support:

[source,java,indent=0]
----
include::../../{doc_code}/embedded/server/http/HTTPServerDocs.java[tags=contextGzipHandler]
----

The `Handler` tree structure looks like the following:

[source,screen]
----
Server
└── ContextHandlerCollection
    └── ContextHandlerCollection
        ├── GzipHandler
        │   └── ContextHandler /shop
        │       └── ShopHandler
        └── ContextHandler /api
            └── RESTHandler
----

// TODO: does ServletContextHandler really need a special configuration?

[[eg-server-http-handler-use-util-rewrite-handler]]
===== RewriteHandler

`RewriteHandler` provides support for URL rewriting, very similarly to
link:https://httpd.apache.org/docs/current/mod/mod_rewrite.html[Apache's mod_rewrite]
or
link:https://nginx.org/en/docs/http/ngx_http_rewrite_module.html[Nginx rewrite module].

The Maven artifact coordinates are:

[source,xml,subs=normal]
----
<dependency>
  <groupId>org.eclipse.jetty</groupId>
  <artifactId>jetty-rewrite</artifactId>
  <version>{version}</version>
</dependency>
----

`RewriteHandler` can be configured with a set of __rule__s; a _rule_ inspects
the request and when it matches it performs some change to the request (for
example, changes the URI path, adds/removes headers, etc.).

The Jetty Server Libraries provide rules for the most common usages, but you
can write your own rules by extending the
`org.eclipse.jetty.rewrite.handler.Rule` class.

Please refer to the `jetty-rewrite` module
link:{JDURL}/org/eclipse/jetty/rewrite/handler/package-summary.html[javadocs]
for the complete list of available rules.

You typically want to configure `RewriteHandler` at the server level, although
it is possible to configure it on a per-context basis.

[source,java,indent=0]
----
include::../../{doc_code}/embedded/server/http/HTTPServerDocs.java[tags=rewriteHandler]
----

The `Handler` tree structure looks like the following:

[source,screen]
----
Server
└── RewriteHandler
    └── ContextHandlerCollection
        ├── ContextHandler 1
        :── ...
        └── ContextHandler N
----

[[eg-server-http-handler-use-util-stats-handler]]
===== StatisticsHandler

`StatisticsHandler` gathers and exposes a number of statistic values related
to request processing such as:

* Total number of requests
* Current number of concurrent requests
* Minimum, maximum, average and standard deviation of request processing times
* Number of responses grouped by HTTP code (i.e. how many `2xx` responses, how
many `3xx` responses, etc.)
* Total response content bytes

Server applications can read these values and use them internally, or expose
them via some service, or export them via JMX.
// TODO: xref to the JMX section.

`StatisticsHandler` can be configured at the server level or at the context
level.

[source,java,indent=0]
----
include::../../{doc_code}/embedded/server/http/HTTPServerDocs.java[tags=statsHandler]
----

The `Handler` tree structure looks like the following:

[source,screen]
----
Server
└── StatisticsHandler
    └── ContextHandlerCollection
        ├── ContextHandler 1
        :── ...
        └── ContextHandler N
----

[[eg-server-http-handler-use-util-secure-handler]]
===== SecuredRedirectHandler -- Redirect from HTTP to HTTPS

// TODO: wait for issue #4766
TODO

[[eg-server-http-handler-use-util-default-handler]]
===== DefaultHandler

`DefaultHandler` is a terminal `Handler` that always calls
`Request.setHandled(true)` and performs the following:

* Serves the `favicon.ico` Jetty icon when it is requested
* Sends a HTTP `404` response for any other request
* The HTTP `404` response content nicely shows a HTML table with all the
contexts deployed on the `Server` instance

`DefaultHandler` is best used as the last `Handler` of a `HandlerList`,
for example:

[source,java,indent=0]
----
include::../../{doc_code}/embedded/server/http/HTTPServerDocs.java[tags=defaultHandler]
----

The `Handler` tree structure looks like the following:

[source,screen]
----
Server
└── HandlerList
    ├── ContextHandlerCollection
    │   ├── ContextHandler 1
    │   :── ...
    │   └── ContextHandler N
    └── DefaultHandler
----

In the example above, `ContextHandlerCollection` will try to match a request
to one of the contexts; if the match fails, `HandlerList` will call the next
`Handler` which is `DefaultHandler` that will return a HTTP `404` with an
HTML page showing the existing contexts deployed on the `Server`.

NOTE: `DefaultHandler` just sends a nicer HTTP `404` response in case of
wrong requests from clients.
Jetty will send an HTTP `404` response anyway if `DefaultHandler` is not
used.
